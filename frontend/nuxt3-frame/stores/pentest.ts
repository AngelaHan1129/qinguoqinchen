// stores/pentest.ts
import { defineStore } from 'pinia'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TypeScript å‹åˆ¥å®šç¾©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface FullPentestResponse {
  success: boolean
  sessionId: string
  executiveSummary: {
    totalVectors: number
    successfulAttacks: number
    failedAttacks: number
    overallSuccessRate: string
    riskLevel: string
    testDuration: string
    timestamp: string
  }
  attackResults: {
    vectors: any[]
    summary: any
    metrics: any
  }
  grokReports: {
    pentestReport: {
      content: string
      model: string
    }
    attackRecommendations: {
      content: string
      model: string
    }
  }
  geminiRecommendations: {
    enterpriseRemediation: any
    defenseStrategy: any
  }
  downloads: {
    pdfReport: string | null
    excelReport: string | null
  }
  metadata: any
}

interface PentestState {
  started: boolean
  loading: boolean
  error: string | null
  results: FullPentestResponse | null
  sessionId: string | null
  tempUrlInput: string
  tempFileInput: File | null
  executionProgress: number
  currentStage: string
}

interface ExecutePentestParams {
  selectedVectors?: string[]
  intensity?: 'low' | 'medium' | 'high'
  targetUrl?: string
  generateReports?: boolean
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pinia Store Definition
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const usePentestStore = defineStore('pentest', {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // State - ç‹€æ…‹å®šç¾©
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  state: (): PentestState => ({
    // æ¸¬è©¦åŸ·è¡Œç‹€æ…‹
    started: false,
    loading: false,
    error: null,

    // æ¸¬è©¦çµæœ
    results: null,
    sessionId: null,

    // åŸ·è¡Œé€²åº¦
    executionProgress: 0,
    currentStage: '',

    // æš«å­˜è¼¸å…¥å€¼ï¼ˆåœ¨ SPA åˆ‡æ›ä¸æœƒè¢«æ¸…æ‰ï¼‰
    tempUrlInput: '',
    tempFileInput: null,
  }),

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Getters - è¨ˆç®—å±¬æ€§
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  getters: {
    isRunning: (state) => state.loading,
    hasResults: (state) => state.results !== null,
    hasError: (state) => state.error !== null,
    progressPercentage: (state) => state.executionProgress,
  },

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Actions - æ–¹æ³•
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  actions: {
    /**
     * ğŸš€ é–‹å§‹æ»²é€æ¸¬è©¦ï¼ˆUI ç‹€æ…‹ï¼‰
     */
    startPentest() {
      this.started = true
      this.error = null
      this.executionProgress = 0
      this.currentStage = ''
    },

    /**
     * ğŸ”„ é‡ç½®æ»²é€æ¸¬è©¦ç‹€æ…‹
     */
    resetPentest() {
      this.started = false
      this.loading = false
      this.error = null
      this.results = null
      this.sessionId = null
      this.executionProgress = 0
      this.currentStage = ''
    },

    /**
     * ğŸ—‘ï¸ æ¸…ç©ºè¼¸å…¥æ¬„ä½
     */
    resetInputs() {
      this.tempUrlInput = ''
      this.tempFileInput = null
    },

    /**
     * ğŸ“Š æ›´æ–°åŸ·è¡Œé€²åº¦
     */
    updateProgress(stage: string, progress: number) {
      this.currentStage = stage
      this.executionProgress = progress
    },

    /**
     * ğŸ¯ åŸ·è¡Œå®Œæ•´æ»²é€æ¸¬è©¦ - æ ¸å¿ƒæ–¹æ³•
     */
    async executeFullPentest(params: ExecutePentestParams): Promise<FullPentestResponse> {
      console.log('ğŸ¯ é–‹å§‹åŸ·è¡Œæ»²é€æ¸¬è©¦...', params)

      this.loading = true
      this.error = null
      this.started = true
      this.executionProgress = 0

      try {
        // âœ… åœ¨ action å…§éƒ¨ä½¿ç”¨ useRuntimeConfig
        const config = useRuntimeConfig()
        const apiBaseUrl = config.public.apiBaseUrl || 'http://localhost:7939'

        // æ¨¡æ“¬é€²åº¦æ›´æ–°
        const stages = [
          'éšæ®µ 1: åŸ·è¡Œæ”»æ“Šæ¸¬è©¦',
          'éšæ®µ 2: ZAP æƒæ',
          'éšæ®µ 3: Grok åˆ†æ',
          'éšæ®µ 4: Grok å»ºè­°',
          'éšæ®µ 5: RAG æª¢ç´¢',
          'éšæ®µ 6: Gemini ä¼æ¥­å»ºè­°',
          'éšæ®µ 7: Gemini é˜²ç¦¦ç­–ç•¥',
          'éšæ®µ 8: ç”Ÿæˆå ±å‘Š'
        ]

        let currentProgress = 0
        const progressInterval = setInterval(() => {
          if (currentProgress < 90) {
            currentProgress += 11.25
            const stageIndex = Math.floor(currentProgress / 12.5)
            if (stageIndex < stages.length) {
              this.updateProgress(stages[stageIndex], currentProgress)
            }
          }
        }, 6000)

        // âœ… å‘¼å«å¾Œç«¯ API
        const response = await fetch(`${apiBaseUrl}/pentest/execute/full`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            vectorIds: params.selectedVectors || ['A1', 'A2', 'A3', 'A4', 'A5'],
            intensity: params.intensity || 'medium',
            targetUrl: params.targetUrl || this.tempUrlInput || 'http://localhost:3000',
            generateReports: params.generateReports !== undefined ? params.generateReports : true,
          }),
        })

        clearInterval(progressInterval)

        // æª¢æŸ¥ HTTP ç‹€æ…‹
        if (!response.ok) {
          const errorText = await response.text()
          throw new Error(`HTTP ${response.status}: ${errorText}`)
        }

        const result: FullPentestResponse = await response.json()

        if (result.success) {
          // ä¿å­˜çµæœåˆ° store
          this.results = result
          this.sessionId = result.sessionId
          this.executionProgress = 100
          this.currentStage = 'âœ… å®Œæˆ'

          console.log('âœ… æ¸¬è©¦å®Œæˆ:', result)

          // é¡¯ç¤ºçµæœï¼ˆconsole è¼¸å‡ºï¼‰
          this.displayResults(result)

          return result
        } else {
          throw new Error('æ¸¬è©¦åŸ·è¡Œå¤±æ•—')
        }
      } catch (error: any) {
        this.error = error.message || 'æœªçŸ¥éŒ¯èª¤'
        console.error('âŒ æ»²é€æ¸¬è©¦åŸ·è¡Œå¤±æ•—:', error)
        throw error
      } finally {
        this.loading = false
      }
    },

    /**
     * ğŸ“Š é¡¯ç¤ºæ¸¬è©¦çµæœï¼ˆConsole è¼¸å‡ºï¼‰
     */
    displayResults(result: FullPentestResponse) {
      console.group('ğŸ“Š æ»²é€æ¸¬è©¦çµæœ')

      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log('ğŸ“‹ åŸ·è¡Œæ‘˜è¦')
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.table(result.executiveSummary)

      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log('âš”ï¸ æ”»æ“Šçµæœ')
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log(result.attackResults)

      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log('ğŸ¤– Grok AI æ»²é€æ¸¬è©¦å ±å‘Š')
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log(result.grokReports.pentestReport.content.substring(0, 500) + '...')

      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log('ğŸ¤– Grok AI æ”»æ“Šå»ºè­°')
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log(result.grokReports.attackRecommendations.content.substring(0, 500) + '...')

      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log('ğŸ›¡ï¸ Gemini é˜²ç¦¦å»ºè­°')
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log(result.geminiRecommendations)

      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log('ğŸ“¥ å ±å‘Šä¸‹è¼‰é€£çµ')
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
      console.log('PDF å ±å‘Š:', result.downloads?.pdfReport || 'ç„¡')
      console.log('Excel å ±å‘Š:', result.downloads?.excelReport || 'ç„¡')

      console.groupEnd()
    },

    /**
     * ğŸ“¥ ä¸‹è¼‰æ¸¬è©¦å ±å‘Š
     */
    async downloadReport(format: 'pdf' | 'excel') {
      if (!this.sessionId) {
        throw new Error('æ²’æœ‰å¯ç”¨çš„ Session ID')
      }

      try {
        console.log(`ğŸ“¥ ä¸‹è¼‰å ±å‘Š: ${format.toUpperCase()}`, this.sessionId)

        // âœ… ä½¿ç”¨ç’°å¢ƒè®Šæ•¸
        const config = useRuntimeConfig()
        const apiBaseUrl = config.public.apiBaseUrl || 'http://localhost:7939'

        const downloadUrl = format === 'pdf'
          ? this.results?.downloads.pdfReport
          : this.results?.downloads.excelReport

        if (!downloadUrl) {
          throw new Error(`${format.toUpperCase()} å ±å‘Šå°šæœªç”Ÿæˆ`)
        }

        // åœ¨æ–°è¦–çª—é–‹å•Ÿä¸‹è¼‰
        window.open(downloadUrl, '_blank')

        console.log('âœ… å ±å‘Šä¸‹è¼‰å·²è§¸ç™¼')
      } catch (error: any) {
        console.error('âŒ ä¸‹è¼‰å ±å‘Šå¤±æ•—:', error)
        this.error = `ä¸‹è¼‰å¤±æ•—: ${error.message}`
        throw error
      }
    },

    /**
     * ğŸ”§ è¨­å®š URL è¼¸å…¥
     */
    setUrlInput(url: string) {
      this.tempUrlInput = url
    },

    /**
     * ğŸ“ è¨­å®šæª”æ¡ˆè¼¸å…¥
     */
    setFileInput(file: File | null) {
      this.tempFileInput = file
    },
  },
})
