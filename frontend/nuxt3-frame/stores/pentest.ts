// stores/pentest.ts
import { defineStore } from 'pinia'

// ═══════════════════════════════════════════
// TypeScript 型別定義
// ═══════════════════════════════════════════

interface FullPentestResponse {
  success: boolean
  sessionId: string
  executiveSummary: {
    totalVectors: number
    successfulAttacks: number
    failedAttacks: number
    overallSuccessRate: string
    riskLevel: string
    testDuration: string
    timestamp: string
  }
  attackResults: {
    vectors: any[]
    summary: any
    metrics: any
  }
  grokReports: {
    pentestReport: {
      content: string
      model: string
    }
    attackRecommendations: {
      content: string
      model: string
    }
  }
  geminiRecommendations: {
    enterpriseRemediation: any
    defenseStrategy: any
  }
  downloads: {
    pdfReport: string | null
    excelReport: string | null
  }
  metadata: any
}

interface PentestState {
  started: boolean
  loading: boolean
  error: string | null
  results: FullPentestResponse | null
  sessionId: string | null
  tempUrlInput: string
  tempFileInput: File | null
  executionProgress: number
  currentStage: string
}

interface ExecutePentestParams {
  selectedVectors?: string[]
  intensity?: 'low' | 'medium' | 'high'
  targetUrl?: string
  generateReports?: boolean
}

// ═══════════════════════════════════════════
// Pinia Store Definition
// ═══════════════════════════════════════════

export const usePentestStore = defineStore('pentest', {
  // ═══════════════════════════════════════════
  // State - 狀態定義
  // ═══════════════════════════════════════════
  state: (): PentestState => ({
    // 測試執行狀態
    started: false,
    loading: false,
    error: null,

    // 測試結果
    results: null,
    sessionId: null,

    // 執行進度
    executionProgress: 0,
    currentStage: '',

    // 暫存輸入值（在 SPA 切換不會被清掉）
    tempUrlInput: '',
    tempFileInput: null,
  }),

  // ═══════════════════════════════════════════
  // Getters - 計算屬性
  // ═══════════════════════════════════════════
  getters: {
    isRunning: (state) => state.loading,
    hasResults: (state) => state.results !== null,
    hasError: (state) => state.error !== null,
    progressPercentage: (state) => state.executionProgress,
  },

  // ═══════════════════════════════════════════
  // Actions - 方法
  // ═══════════════════════════════════════════
  actions: {
    /**
     * 🚀 開始滲透測試（UI 狀態）
     */
    startPentest() {
      this.started = true
      this.error = null
      this.executionProgress = 0
      this.currentStage = ''
    },

    /**
     * 🔄 重置滲透測試狀態
     */
    resetPentest() {
      this.started = false
      this.loading = false
      this.error = null
      this.results = null
      this.sessionId = null
      this.executionProgress = 0
      this.currentStage = ''
    },

    /**
     * 🗑️ 清空輸入欄位
     */
    resetInputs() {
      this.tempUrlInput = ''
      this.tempFileInput = null
    },

    /**
     * 📊 更新執行進度
     */
    updateProgress(stage: string, progress: number) {
      this.currentStage = stage
      this.executionProgress = progress
    },

    /**
     * 🎯 執行完整滲透測試 - 核心方法
     */
    async executeFullPentest(params: ExecutePentestParams): Promise<FullPentestResponse> {
      console.log('🎯 開始執行滲透測試...', params)

      this.loading = true
      this.error = null
      this.started = true
      this.executionProgress = 0

      try {
        // ✅ 在 action 內部使用 useRuntimeConfig
        const config = useRuntimeConfig()
        const apiBaseUrl = config.public.apiBaseUrl || 'http://localhost:7939'

        // 模擬進度更新
        const stages = [
          '階段 1: 執行攻擊測試',
          '階段 2: ZAP 掃描',
          '階段 3: Grok 分析',
          '階段 4: Grok 建議',
          '階段 5: RAG 檢索',
          '階段 6: Gemini 企業建議',
          '階段 7: Gemini 防禦策略',
          '階段 8: 生成報告'
        ]

        let currentProgress = 0
        const progressInterval = setInterval(() => {
          if (currentProgress < 90) {
            currentProgress += 11.25
            const stageIndex = Math.floor(currentProgress / 12.5)
            if (stageIndex < stages.length) {
              this.updateProgress(stages[stageIndex], currentProgress)
            }
          }
        }, 6000)

        // ✅ 呼叫後端 API
        const response = await fetch(`${apiBaseUrl}/pentest/execute/full`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            vectorIds: params.selectedVectors || ['A1', 'A2', 'A3', 'A4', 'A5'],
            intensity: params.intensity || 'medium',
            targetUrl: params.targetUrl || this.tempUrlInput || 'http://localhost:3000',
            generateReports: params.generateReports !== undefined ? params.generateReports : true,
          }),
        })

        clearInterval(progressInterval)

        // 檢查 HTTP 狀態
        if (!response.ok) {
          const errorText = await response.text()
          throw new Error(`HTTP ${response.status}: ${errorText}`)
        }

        const result: FullPentestResponse = await response.json()

        if (result.success) {
          // 保存結果到 store
          this.results = result
          this.sessionId = result.sessionId
          this.executionProgress = 100
          this.currentStage = '✅ 完成'

          console.log('✅ 測試完成:', result)

          // 顯示結果（console 輸出）
          this.displayResults(result)

          return result
        } else {
          throw new Error('測試執行失敗')
        }
      } catch (error: any) {
        this.error = error.message || '未知錯誤'
        console.error('❌ 滲透測試執行失敗:', error)
        throw error
      } finally {
        this.loading = false
      }
    },

    /**
     * 📊 顯示測試結果（Console 輸出）
     */
    displayResults(result: FullPentestResponse) {
      console.group('📊 滲透測試結果')

      console.log('═══════════════════════════════════')
      console.log('📋 執行摘要')
      console.log('═══════════════════════════════════')
      console.table(result.executiveSummary)

      console.log('═══════════════════════════════════')
      console.log('⚔️ 攻擊結果')
      console.log('═══════════════════════════════════')
      console.log(result.attackResults)

      console.log('═══════════════════════════════════')
      console.log('🤖 Grok AI 滲透測試報告')
      console.log('═══════════════════════════════════')
      console.log(result.grokReports.pentestReport.content.substring(0, 500) + '...')

      console.log('═══════════════════════════════════')
      console.log('🤖 Grok AI 攻擊建議')
      console.log('═══════════════════════════════════')
      console.log(result.grokReports.attackRecommendations.content.substring(0, 500) + '...')

      console.log('═══════════════════════════════════')
      console.log('🛡️ Gemini 防禦建議')
      console.log('═══════════════════════════════════')
      console.log(result.geminiRecommendations)

      console.log('═══════════════════════════════════')
      console.log('📥 報告下載連結')
      console.log('═══════════════════════════════════')
      console.log('PDF 報告:', result.downloads?.pdfReport || '無')
      console.log('Excel 報告:', result.downloads?.excelReport || '無')

      console.groupEnd()
    },

    /**
     * 📥 下載測試報告
     */
    async downloadReport(format: 'pdf' | 'excel') {
      if (!this.sessionId) {
        throw new Error('沒有可用的 Session ID')
      }

      try {
        console.log(`📥 下載報告: ${format.toUpperCase()}`, this.sessionId)

        // ✅ 使用環境變數
        const config = useRuntimeConfig()
        const apiBaseUrl = config.public.apiBaseUrl || 'http://localhost:7939'

        const downloadUrl = format === 'pdf'
          ? this.results?.downloads.pdfReport
          : this.results?.downloads.excelReport

        if (!downloadUrl) {
          throw new Error(`${format.toUpperCase()} 報告尚未生成`)
        }

        // 在新視窗開啟下載
        window.open(downloadUrl, '_blank')

        console.log('✅ 報告下載已觸發')
      } catch (error: any) {
        console.error('❌ 下載報告失敗:', error)
        this.error = `下載失敗: ${error.message}`
        throw error
      }
    },

    /**
     * 🔧 設定 URL 輸入
     */
    setUrlInput(url: string) {
      this.tempUrlInput = url
    },

    /**
     * 📁 設定檔案輸入
     */
    setFileInput(file: File | null) {
      this.tempFileInput = file
    },
  },
})
