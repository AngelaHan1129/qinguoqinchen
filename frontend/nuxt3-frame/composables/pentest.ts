// composables/pentest.ts
import { onMounted, onUnmounted, ref, computed } from 'vue'
import { usePentestUI } from '@/composables/dashboard'
import type { AttackModVector } from '@/composables/getapi'

// 定義完整測試回應類型
interface FullPentestResponse {
    success: boolean
    sessionId: string
    executiveSummary: {
        totalVectors: number
        successfulAttacks: number
        failedAttacks: number
        overallSuccessRate: string
        riskLevel: string
        testDuration: string
        timestamp: string
    }
    attackResults: {
        vectors: any[]
        summary: any
        metrics: any
    }
    grokReports: {
        pentestReport: {
            content: string
            model: string
        }
        attackRecommendations: {
            content: string
            model: string
        }
    }
    downloads: {
        pdfReport: string | null
        excelReport: string | null
    }
    metadata: any
}

// ✅ 新增:執行完整滲透測試
async function executeFullPentestAPI(config: {
    vectorIds: string[]
    intensity: 'low' | 'medium' | 'high'
    targetUrl: string
    generateReports: boolean
}): Promise<FullPentestResponse> {
    const response = await fetch(`${process.env.NUXT_PUBLIC_API_BASE_URL}/pentest/execute/full`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(config)
    })

    if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    return await response.json()
}

// 主要的 pentest composable
export function usePentestMain() {
    const { urlInput, selectedFileName } = usePentestUI()

    const attackMods = ref<(AttackModVector & { selected: boolean })[]>([])
    const attackIntensity = ref<'low' | 'medium' | 'high'>('high')
    const isExecuting = ref(false)
    const logs = ref<Array<{ timestamp: string; level: string; message: string }>>([])
    const pentestResult = ref<FullPentestResponse | null>(null)

    // ✅ 修正:處理攻擊模組送出 - 使用新 API
    async function handleSubmitAttackMods() {
        const selectedMods = attackMods.value.filter(mod => mod.selected)

        if (selectedMods.length === 0) {
            addLogEntry('warning', '請至少選擇一個 AI 攻擊模組')
            return
        }

        if (isExecuting.value) {
            addLogEntry('warning', '攻擊測試正在執行中，請稍候...')
            return
        }

        isExecuting.value = true

        // 記錄選中的模組
        addLogEntry('info', `已選擇 ${selectedMods.length} 個 AI 攻擊模組`)
        selectedMods.forEach(mod => {
            addLogEntry('info', `- ${mod.model} (難度: ${mod.difficulty})`)
        })

        // 開始攻擊測試
        addLogEntry('success', `開始執行完整滲透測試 (強度: ${attackIntensity.value.toUpperCase()})...`)

        try {
            // ✅ 呼叫完整滲透測試 API
            const config = {
                vectorIds: selectedMods.map(mod => mod.id),
                intensity: attackIntensity.value,
                targetUrl: urlInput.value || 'https://bank-ekyc.example.com',
                generateReports: true
            }

            addLogEntry('info', '正在執行完整滲透測試流程...')
            addLogEntry('info', '階段 1/8: 執行攻擊測試...')

            const result = await executeFullPentestAPI(config)
            pentestResult.value = result

            if (result.success) {
                addLogEntry('success', `✅ 滲透測試完成！Session ID: ${result.sessionId}`)

                // 記錄執行摘要
                const summary = result.executiveSummary
                addLogEntry('info', `總攻擊向量: ${summary.totalVectors}`)
                addLogEntry('info', `成功攻擊數: ${summary.successfulAttacks}`)
                addLogEntry('info', `失敗攻擊數: ${summary.failedAttacks}`)
                addLogEntry('info', `成功率: ${summary.overallSuccessRate}`)
                addLogEntry('warning', `風險等級: ${summary.riskLevel}`)
                addLogEntry('info', `執行時間: ${summary.testDuration}`)

                // 記錄報告生成狀態
                if (result.downloads.pdfReport) {
                    addLogEntry('success', `📄 PDF 報告已生成: ${result.downloads.pdfReport}`)
                }
                if (result.downloads.excelReport) {
                    addLogEntry('success', `📊 Excel 報告已生成: ${result.downloads.excelReport}`)
                }

                // 儲存結果到 localStorage
                localStorage.setItem('pentestResult', JSON.stringify(result))

                // ✅ 3秒後自動跳轉到報告頁面
                addLogEntry('success', '✨ 3秒後將自動跳轉到報告頁面...')
                setTimeout(() => {
                    navigateTo({
                        path: '/reports',
                        query: { sessionId: result.sessionId }
                    })
                }, 3000)

            } else {
                addLogEntry('error', '❌ 滲透測試執行失敗')
            }

        } catch (error) {
            addLogEntry('error', `❌ 攻擊測試啟動失敗: ${error}`)
            console.error('攻擊執行錯誤:', error)
        } finally {
            isExecuting.value = false
        }
    }

    function addLogEntry(level: string, message: string) {
        const entry = {
            timestamp: new Date().toLocaleTimeString('zh-TW'),
            level,
            message
        }
        logs.value.push(entry)

        // 更新 DOM
        const logContainer = document.getElementById('logContainer')
        if (logContainer) {
            const logElement = document.createElement('div')
            logElement.className = `log-entry log-${level}`
            logElement.textContent = `[${entry.timestamp}] ${level.toUpperCase()} - ${entry.message}`
            logContainer.appendChild(logElement)
            logContainer.scrollTop = logContainer.scrollHeight
        }
    }

    function clearLogs() {
        logs.value = []
        const logContainer = document.getElementById('logContainer')
        if (logContainer) {
            logContainer.innerHTML = ''
        }
        addLogEntry('info', '日誌已清空')
    }

    const selectedModsCount = computed(() =>
        attackMods.value.filter(mod => mod.selected).length
    )

    const hasSelectedMods = computed(() => selectedModsCount.value > 0)

    return {
        urlInput,
        selectedFileName,
        attackMods,
        selectedModsCount,
        hasSelectedMods,
        attackIntensity,
        isExecuting,
        handleSubmitAttackMods,
        clearLogs,
        logs,
        pentestResult
    }
}
