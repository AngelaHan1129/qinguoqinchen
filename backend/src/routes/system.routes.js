// src/routes/system.routes.js
const ErrorHandler = require('../utils/errorHandler');
const Logger = require('../utils/logger');

class SystemRoutes {
    static register(app, services) {
        const { appService, healthService } = services;

        // È¶ñÈ†ÅÁ´ØÈªû
        app.get('/', (req, res) => {
            Logger.info('Ë®™ÂïèÈ¶ñÈ†Å');

            const welcomeMessage = {
                system: '‰æµÂúã‰æµÂüé AI Êª≤ÈÄèÊ∏¨Ë©¶Á≥ªÁµ±',
                version: '1.0.0',
                description: 'Â∞àÊ•≠ÁöÑ eKYC Á≥ªÁµ± AI ÂÆâÂÖ®Ê∏¨Ë©¶Âπ≥Âè∞',
                status: 'operational',
                timestamp: new Date().toISOString(),

                quickStart: {
                    documentation: '/api/docs',
                    healthCheck: '/health',
                    systemInfo: '/system/info',
                    attackVectors: '/ai-attack/vectors'
                },

                capabilities: [
                    'üéØ Â§öÈáç AI ÊîªÊìäÂêëÈáèÊ®°Êì¨',
                    'ü§ñ Gemini AI ÂÆâÂÖ®ÂàÜÊûê',
                    'üöÄ Grok AI Â®ÅËÑÖË©ï‰º∞',
                    'üß† Vertex AI Êô∫ËÉΩ‰ª£ÁêÜ',
                    'üìö RAG Áü•Ë≠òÁÆ°ÁêÜÁ≥ªÁµ±',
                    'üîç ÈáèÂåñÈ¢®Èö™Ë©ï‰º∞ (APCER/BPCER)',
                    'üìä Âç≥ÊôÇÊïàËÉΩÁõ£Êéß',
                    'üõ°Ô∏è ‰ºÅÊ•≠Á¥öÂÆâÂÖ®Èò≤Ë≠∑'
                ],

                team: '‰æµÂúã‰æµÂüéÂúòÈöä',
                competition: '2025 InnoServe Â§ßÂ∞àÊ†°Èô¢Ë≥áË®äÊáâÁî®ÊúçÂãôÂâµÊñ∞Á´∂Ë≥Ω',
                university: 'ÂúãÁ´ãËá∫‰∏≠ÁßëÊäÄÂ§ßÂ≠∏'
            };

            res.json(welcomeMessage);
        });

        // Á≥ªÁµ±Ë≥áË®ä
        app.get('/system/info', ErrorHandler.asyncHandler(async (req, res) => {
            Logger.info('ÂèñÂæóÁ≥ªÁµ±Ë≥áË®ä');
            const systemInfo = appService.getSystemInfo();
            res.json({
                success: true,
                ...systemInfo
            });
        }));

        // ÂÅ•Â∫∑Ê™¢Êü• (Á∞°ÂåñÁâà)
        app.get('/health', ErrorHandler.asyncHandler(async (req, res) => {
            Logger.info('Âü∑Ë°åÂÅ•Â∫∑Ê™¢Êü•');
            const health = healthService.getSystemHealth();

            // Ë®≠ÂÆöÈÅ©Áï∂ÁöÑ HTTP ÁãÄÊÖãÁ¢º
            const statusCode = health.status === 'healthy' ? 200 : 503;

            res.status(statusCode).json({
                success: health.status === 'healthy',
                ...health
            });
        }));

        // Ê∑±Â∫¶ÂÅ•Â∫∑Ê™¢Êü•
        app.get('/health/deep', ErrorHandler.asyncHandler(async (req, res) => {
            Logger.info('Âü∑Ë°åÊ∑±Â∫¶ÂÅ•Â∫∑Ê™¢Êü•');

            try {
                const deepHealth = await healthService.performDeepHealthCheck();
                const statusCode = deepHealth.overallStatus === 'healthy' ? 200 : 503;

                res.status(statusCode).json({
                    success: deepHealth.overallStatus === 'healthy',
                    ...deepHealth
                });
            } catch (error) {
                Logger.error('Ê∑±Â∫¶ÂÅ•Â∫∑Ê™¢Êü•Â§±Êïó', { error: error.message });
                res.status(500).json({
                    success: false,
                    overallStatus: 'error',
                    error: 'ÂÅ•Â∫∑Ê™¢Êü•Âü∑Ë°åÂ§±Êïó',
                    message: error.message,
                    timestamp: new Date().toISOString()
                });
            }
        }));

        // Á≥ªÁµ±Áµ±Ë®à
        app.get('/system/statistics', ErrorHandler.asyncHandler(async (req, res) => {
            Logger.info('ÂèñÂæóÁ≥ªÁµ±Áµ±Ë®à');

            const statistics = {
                uptime: Math.floor(process.uptime()),
                memory: process.memoryUsage(),
                cpu: {
                    architecture: process.arch,
                    platform: process.platform,
                    nodeVersion: process.version
                },
                environment: process.env.NODE_ENV || 'development',
                timestamp: new Date().toISOString(),

                // ÊáâÁî®Á®ãÂºèÁµ±Ë®à
                application: {
                    startTime: new Date(Date.now() - process.uptime() * 1000).toISOString(),
                    processId: process.pid,
                    workingDirectory: process.cwd(),
                    execPath: process.execPath
                },

                // ÂäüËÉΩ‰ΩøÁî®Áµ±Ë®à
                features: {
                    aiServices: {
                        gemini: !!process.env.GEMINI_API_KEY,
                        grok: !!process.env.XAI_API_KEY,
                        vertexAI: !!process.env.GOOGLE_CLOUD_PROJECT_ID
                    },
                    databases: {
                        postgresql: !!process.env.DATABASE_URL,
                        neo4j: !!(process.env.NEO4J_URI && process.env.NEO4J_USERNAME),
                        redis: !!process.env.REDIS_URL
                    }
                }
            };

            res.json({
                success: true,
                statistics
            });
        }));

        // Á≥ªÁµ±ÁãÄÊÖã
        app.get('/system/status', ErrorHandler.asyncHandler(async (req, res) => {
            Logger.info('ÂèñÂæóÁ≥ªÁµ±ÁãÄÊÖã');

            const memoryUsage = process.memoryUsage();
            const uptime = process.uptime();

            const status = {
                status: 'operational',
                timestamp: new Date().toISOString(),
                uptime: {
                    seconds: Math.floor(uptime),
                    humanReadable: this.formatUptime(uptime)
                },

                resources: {
                    memory: {
                        used: Math.round(memoryUsage.heapUsed / 1024 / 1024),
                        total: Math.round(memoryUsage.heapTotal / 1024 / 1024),
                        percentage: Math.round((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100),
                        unit: 'MB'
                    },

                    load: {
                        current: this.getSystemLoad(),
                        status: this.getLoadStatus()
                    }
                },

                components: {
                    webServer: { status: 'running', port: process.env.PORT || 7939 },
                    apiEndpoints: { status: 'available', count: '35+' },
                    aiServices: {
                        status: this.getAIServicesStatus(),
                        configured: this.countConfiguredServices()
                    },
                    databases: {
                        status: this.getDatabasesStatus(),
                        configured: this.countConfiguredDatabases()
                    }
                },

                security: {
                    cors: 'enabled',
                    rateLimiting: 'enabled',
                    inputValidation: 'enabled',
                    errorHandling: 'centralized'
                }
            };

            res.json({
                success: true,
                ...status
            });
        }));

        // Á≥ªÁµ±ÁâàÊú¨Ë≥áË®ä
        app.get('/system/version', (req, res) => {
            Logger.info('ÂèñÂæóÁâàÊú¨Ë≥áË®ä');

            const packageInfo = require('../../../package.json');

            const versionInfo = {
                application: {
                    name: packageInfo.name || '‰æµÂúã‰æµÂüé AI Êª≤ÈÄèÊ∏¨Ë©¶Á≥ªÁµ±',
                    version: packageInfo.version || '1.0.0',
                    description: packageInfo.description,
                    author: packageInfo.author
                },

                runtime: {
                    node: process.version,
                    platform: process.platform,
                    architecture: process.arch
                },

                dependencies: {
                    framework: 'NestJS + Express',
                    ai: ['Gemini AI', 'Grok AI', 'Vertex AI'],
                    databases: ['PostgreSQL', 'Neo4j', 'Redis'],
                    other: ['Swagger', 'Multer', 'Bcrypt']
                },

                buildInfo: {
                    buildTime: process.env.BUILD_TIME || 'development',
                    commit: process.env.GIT_COMMIT || 'local',
                    branch: process.env.GIT_BRANCH || 'main',
                    environment: process.env.NODE_ENV || 'development'
                },

                timestamp: new Date().toISOString()
            };

            res.json({
                success: true,
                version: versionInfo
            });
        });

        // Á≥ªÁµ±ÈÖçÁΩÆË≥áË®ä (ÊïèÊÑüË≥áË®äÂ∑≤Èö±Ëóè)
        app.get('/system/config', (req, res) => {
            Logger.info('ÂèñÂæóÁ≥ªÁµ±ÈÖçÁΩÆ');

            const config = {
                server: {
                    port: process.env.PORT || 7939,
                    environment: process.env.NODE_ENV || 'development',
                    cors: process.env.CORS_ORIGIN || '*'
                },

                features: {
                    swagger: true,
                    rateLimiting: true,
                    fileUpload: true,
                    compression: true
                },

                ai: {
                    gemini: { configured: !!process.env.GEMINI_API_KEY, model: 'gemini-2.5-flash' },
                    grok: { configured: !!process.env.XAI_API_KEY, model: 'grok-beta' },
                    vertexAI: { configured: !!process.env.GOOGLE_CLOUD_PROJECT_ID, location: process.env.VERTEX_AI_LOCATION }
                },

                databases: {
                    postgresql: { configured: !!process.env.DATABASE_URL },
                    neo4j: { configured: !!(process.env.NEO4J_URI && process.env.NEO4J_USERNAME) },
                    redis: { configured: !!process.env.REDIS_URL }
                },

                limits: {
                    fileUpload: '10MB',
                    requestSize: '10MB',
                    rateLimit: '100 requests/15min'
                },

                timestamp: new Date().toISOString()
            };

            res.json({
                success: true,
                config
            });
        });

        // Á≥ªÁµ±Êó•Ë™å (ÊúÄËøëÁöÑÈåØË™§ÂíåË≠¶Âëä)
        app.get('/system/logs', (req, res) => {
            const { level = 'all', limit = 100 } = req.query;

            Logger.info('ÂèñÂæóÁ≥ªÁµ±Êó•Ë™å', { level, limit });

            // ÈÄôË£°ÊáâË©≤ÂæûÂØ¶ÈöõÁöÑÊó•Ë™åÁ≥ªÁµ±ÂèñÂæóË≥áÊñô
            const logs = {
                summary: {
                    total: 0,
                    errors: 0,
                    warnings: 0,
                    info: 0
                },

                entries: [
                    {
                        timestamp: new Date().toISOString(),
                        level: 'INFO',
                        message: 'Á≥ªÁµ±Ê≠£Â∏∏ÈÅãË°å',
                        source: 'system'
                    }
                ],

                disclaimer: 'ÈÄôÊòØÊ®°Êì¨Ë≥áÊñôÔºåÂØ¶ÈöõÈÉ®ÁΩ≤ÊôÇÈúÄË¶ÅÊï¥ÂêàÁúüÂØ¶ÁöÑÊó•Ë™åÁ≥ªÁµ±',

                timestamp: new Date().toISOString()
            };

            res.json({
                success: true,
                logs
            });
        });

        // ËºîÂä©ÊñπÊ≥ï
        SystemRoutes.formatUptime = (uptimeSeconds) => {
            const days = Math.floor(uptimeSeconds / (24 * 60 * 60));
            const hours = Math.floor((uptimeSeconds % (24 * 60 * 60)) / (60 * 60));
            const minutes = Math.floor((uptimeSeconds % (60 * 60)) / 60);
            const seconds = Math.floor(uptimeSeconds % 60);

            if (days > 0) return `${days}Â§© ${hours}Â∞èÊôÇ ${minutes}ÂàÜÈêò`;
            if (hours > 0) return `${hours}Â∞èÊôÇ ${minutes}ÂàÜÈêò`;
            if (minutes > 0) return `${minutes}ÂàÜÈêò ${seconds}Áßí`;
            return `${seconds}Áßí`;
        };

        SystemRoutes.getSystemLoad = () => {
            const memoryUsage = process.memoryUsage();
            const heapUsedPercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;
            return `${heapUsedPercent.toFixed(1)}%`;
        };

        SystemRoutes.getLoadStatus = () => {
            const memoryUsage = process.memoryUsage();
            const heapUsedPercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;

            if (heapUsedPercent > 90) return 'critical';
            if (heapUsedPercent > 75) return 'high';
            if (heapUsedPercent > 50) return 'moderate';
            return 'low';
        };

        SystemRoutes.getAIServicesStatus = () => {
            const configured = [
                !!process.env.GEMINI_API_KEY,
                !!process.env.XAI_API_KEY,
                !!process.env.GOOGLE_CLOUD_PROJECT_ID
            ].filter(Boolean).length;

            if (configured === 3) return 'fully-configured';
            if (configured > 0) return 'partially-configured';
            return 'not-configured';
        };

        SystemRoutes.countConfiguredServices = () => {
            return [
                !!process.env.GEMINI_API_KEY,
                !!process.env.XAI_API_KEY,
                !!process.env.GOOGLE_CLOUD_PROJECT_ID
            ].filter(Boolean).length;
        };

        SystemRoutes.getDatabasesStatus = () => {
            const configured = [
                !!process.env.DATABASE_URL,
                !!(process.env.NEO4J_URI && process.env.NEO4J_USERNAME),
                !!process.env.REDIS_URL
            ].filter(Boolean).length;

            if (configured === 3) return 'fully-configured';
            if (configured > 0) return 'partially-configured';
            return 'not-configured';
        };

        SystemRoutes.countConfiguredDatabases = () => {
            return [
                !!process.env.DATABASE_URL,
                !!(process.env.NEO4J_URI && process.env.NEO4J_USERNAME),
                !!process.env.REDIS_URL
            ].filter(Boolean).length;
        };

        Logger.success('System Ë∑ØÁî±Ë®ªÂÜäÂÆåÊàê', { routes: 8 });
        return 8;
    }
}

module.exports = SystemRoutes;
