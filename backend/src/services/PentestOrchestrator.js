// src/services/PentestOrchestrator.js - 完整整合版本
const Logger = require('../utils/logger');
const { generatePentestReport } = require('./reportService');

class PentestOrchestrator {
    constructor(services) {
        const {
            attackService,
            grokService,
            geminiService,
            ragService,
            complianceReportService,
            zapService
        } = services;

        this.attackService = attackService;
        this.grokService = grokService;
        this.geminiService = geminiService;
        this.ragService = ragService;
        this.complianceReportService = complianceReportService;
        this.zapService = zapService;

        Logger.info('✅ PentestOrchestrator 初始化成功');
    }

    // ═══════════════════════════════════════════
    // 核心方法：執行完整滲透測試流程
    // ═══════════════════════════════════════════
    async executeFullPenetrationTest(params) {
        const {
            vectorIds = ['A1', 'A2', 'A3', 'A4', 'A5'],
            intensity = 'medium',
            targetUrl = 'http://localhost:3000',
            generateReports = true
        } = params;

        const sessionId = this.generateSessionId();
        const startTime = Date.now();
        const { reportMarkdown, results } = await generatePentestReport({
            vectorIds: params.vectorIds,
            intensity: params.intensity,
            targetUrl: params.targetUrl,
            modelInfo: params.modelInfo, // 支援客製
            clientName: params.clientName,
            testStartTime: params.testStartTime,
            testEndTime: Date.now(),
            testUser: params.testUser
        });
        Logger.info('🎯 開始執行完整滲透測試', {
            sessionId,
            vectorIds,
            intensity,
            targetUrl
        });

        try {
            // ═══════════════════════════════════════════
            // 階段 1: 執行攻擊測試
            // ═══════════════════════════════════════════
            Logger.info('⚔️ 階段 1: 執行攻擊測試');
            const attackResults = await this.executeAttacks(vectorIds, intensity, targetUrl);

            // ═══════════════════════════════════════════
            // 階段 2: ZAP 掃描（可選）
            // ═══════════════════════════════════════════
            let zapResults = null;
            if (this.zapService) {
                Logger.info('🔍 階段 2: 執行 ZAP 掃描（可選）');
                zapResults = await this.executeZAPScan(targetUrl);
            }

            // ═══════════════════════════════════════════
            // 階段 3: Grok 生成滲透測試報告
            // ═══════════════════════════════════════════
            Logger.info('📊 階段 3: Grok 生成滲透測試報告');
            // 呼叫處（orchestrator 或 controller）
            const grokPentestReport = await this.grokService.generatePentestReport(
                attackResults,            // 第一個參數
                zapResults,               // 第二個參數
                {                        // 第三個參數，這裡要傳 systemContext 或 targetInfo
                    url: targetUrl,
                    type: 'eKYC System',
                    version: '1.0',
                    industry: '金融'
                }
            );


            // ═══════════════════════════════════════════
            // 階段 4: Grok 生成攻擊者下次建議
            // ═══════════════════════════════════════════
            Logger.info('⚔️ 階段 4: Grok 生成攻擊者下次建議');
            const grokAttackRecommendations = await this.grokService.generateNextAttackRecommendations(
                attackResults,
                zapResults,
                [] // 可傳入歷史攻擊記錄
            );

            // ═══════════════════════════════════════════
            // 階段 5: RAG 檢索相關安全知識
            // ═══════════════════════════════════════════
            Logger.info('📚 階段 5: RAG 檢索安全知識庫');
            const ragContext = await this.retrieveRelevantKnowledge(
                attackResults,
                grokPentestReport.response
            );

            // ═══════════════════════════════════════════
            // 階段 6: Gemini 生成企業改善建議（基於 Grok 報告 + RAG）
            // ═══════════════════════════════════════════
            Logger.info('🛡️ 階段 6: Gemini 生成企業改善建議');
            const geminiEnterpriseRemediation = await this.executeStage6_GeminiRemediation(
                grokPentestReport,
                ragContext
            );

            // ═══════════════════════════════════════════
            // 階段 7: Gemini 生成防禦策略（基於 Grok 攻擊建議 + RAG）
            // ═══════════════════════════════════════════
            Logger.info('🛡️ 階段 7: Gemini 生成防禦策略');
            const geminiDefenseStrategy = await this.executeStage7_GeminiDefense(
                grokAttackRecommendations,
                ragContext
            );

            // ═══════════════════════════════════════════
            // 階段 8: 生成 PDF/Excel 報告（可選）
            // ═══════════════════════════════════════════
            let reportFiles = null;
            if (generateReports && this.complianceReportService) {
                Logger.info('📄 階段 8: 生成 PDF 和 Excel 報告');
                reportFiles = await this.generateComplianceReports(
                    sessionId,
                    {
                        attackResults,
                        grokPentestReport,
                        grokAttackRecommendations,
                        geminiEnterpriseRemediation,
                        geminiDefenseStrategy,
                        ragContext
                    }
                );
            }

            // ═══════════════════════════════════════════
            // 階段 9: 組裝最終結果
            // ═══════════════════════════════════════════
            const executionTime = Date.now() - startTime;
            const summary = attackResults?.summary || {};
            const results = attackResults?.results || [];

            const finalResult = {
                success: true,
                sessionId,

                // 執行摘要
                executiveSummary: {
                    totalVectors: vectorIds.length,
                    successfulAttacks: summary.successfulAttacks || 0,
                    failedAttacks: (summary.totalAttacks || vectorIds.length) - (summary.successfulAttacks || 0),
                    overallSuccessRate: summary.overallSuccessRate || '0%',
                    riskLevel: summary.riskLevel || 'UNKNOWN',
                    testDuration: this.formatDuration(executionTime),
                    timestamp: new Date().toISOString()
                },

                // 攻擊結果（原始數據）
                attackResults: {
                    vectors: results,
                    summary: summary,
                    metrics: this.calculateSecurityMetrics(results)
                },

                // ZAP 掃描結果（可選）
                zapResults: zapResults || null,

                // 🔴 Grok 生成的報告（給技術團隊看）
                grokReports: {
                    pentestReport: {
                        content: grokPentestReport?.response || '',
                        model: grokPentestReport?.model || 'unknown',
                        timestamp: grokPentestReport?.timestamp || new Date().toISOString()
                    },
                    attackRecommendations: {
                        content: grokAttackRecommendations?.response || '',
                        model: grokAttackRecommendations?.model || 'unknown',
                        timestamp: grokAttackRecommendations?.timestamp || new Date().toISOString()
                    }
                },

                // 🟢 Gemini 生成的建議（給企業/管理層看）
                geminiRecommendations: {
                    enterpriseRemediation: {
                        content: geminiEnterpriseRemediation?.remediationPlan || '',
                        model: geminiEnterpriseRemediation?.model || 'fallback',
                        confidence: geminiEnterpriseRemediation?.confidence || 0.5,
                        ragSourcesUsed: geminiEnterpriseRemediation?.ragSourcesUsed || 0,
                        timestamp: geminiEnterpriseRemediation?.timestamp || new Date().toISOString()
                    },
                    defenseStrategy: {
                        content: geminiDefenseStrategy?.defenseStrategy || '',
                        model: geminiDefenseStrategy?.model || 'fallback',
                        confidence: geminiDefenseStrategy?.confidence || 0.5,
                        ragSourcesUsed: geminiDefenseStrategy?.ragSourcesUsed || 0,
                        timestamp: geminiDefenseStrategy?.timestamp || new Date().toISOString()
                    }
                },

                // RAG 知識庫來源
                ragContext: {
                    totalSources: Array.isArray(ragContext) ? ragContext.length : 0,
                    sources: Array.isArray(ragContext) ? ragContext.map(doc => ({
                        title: doc?.title || 'Unknown',
                        category: doc?.category || 'general',
                        similarity: doc?.similarity || 0
                    })) : []
                },

                // 下載連結
                downloads: {
                    pdfReport: reportFiles?.pdfPath || null,
                    excelReport: reportFiles?.excelPath || null
                },

                // 元數據
                metadata: {
                    executionTime: `${executionTime}ms`,
                    generatedAt: new Date().toISOString(),
                    version: '2.0.0',
                    system: '侵國侵城 AI 滲透測試系統',
                    aiModels: {
                        attackAnalysis: 'Grok AI',
                        enterpriseRemediation: 'Gemini 2.5 Flash',
                        knowledgeBase: 'RAG (pgvector)'
                    }
                }
            };

            Logger.success('✅ 完整滲透測試執行成功', {
                sessionId,
                duration: executionTime,
                successRate: summary.overallSuccessRate || '0%'
            });

            return finalResult;

        } catch (error) {
            Logger.error('❌ 滲透測試執行失敗', error.message);

            return {
                success: false,
                sessionId,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }

    // ═══════════════════════════════════════════
    // 輔助方法：執行攻擊測試
    // ═══════════════════════════════════════════
    async executeAttacks(vectorIds, intensity, targetUrl) {
        Logger.info('⚔️ 執行攻擊向量測試', { vectorIds, intensity });

        const attackResult = this.attackService.executeAttack({
            vectorIds,
            intensity,
            targetImage: null,
            targetUrl,
            options: {}
        });

        return attackResult;
    }

    // ═══════════════════════════════════════════
    // 輔助方法：執行 ZAP 掃描
    // ═══════════════════════════════════════════
    async executeZAPScan(targetUrl) {
        if (!this.zapService) {
            Logger.warn('⚠️ ZAP Service 不可用，跳過掃描');
            return null;
        }

        try {
            Logger.info('🔍 執行 OWASP ZAP 掃描');
            // 假設 zapService 有 scan 方法
            const zapResult = await this.zapService.scan(targetUrl);
            return zapResult;
        } catch (error) {
            Logger.warn('⚠️ ZAP 掃描失敗', error.message);
            return null;
        }
    }

    // ═══════════════════════════════════════════
    // 輔助方法：RAG 檢索相關知識
    // ═══════════════════════════════════════════
    async retrieveRelevantKnowledge(attackResults, grokReport) {
        if (!this.ragService) {
            Logger.warn('⚠️ RAG Service 不可用');
            return [];
        }

        try {
            Logger.info('📚 檢索 RAG 知識庫');

            // ✅ 修正：安全地提取攻擊向量名稱
            const vectorNames = (attackResults?.results || [])
                .map(r => r.vectorName || 'Unknown')
                .filter(name => name !== 'Unknown')
                .join(', ') || '未知攻擊向量';

            const queryText = `
eKYC 安全漏洞修復建議
攻擊向量: ${vectorNames}
風險等級: ${attackResults?.summary?.riskLevel || 'UNKNOWN'}
成功率: ${attackResults?.summary?.overallSuccessRate || '0%'}
`;

            // ✅ 檢查 RAG Service 是否有正確的方法
            let ragResults = [];

            if (typeof this.ragService.searchRelevantDocuments === 'function') {
                ragResults = await this.ragService.searchRelevantDocuments(
                    queryText,
                    { topK: 5, category: 'security', documentType: 'remediation' }
                );
            } else if (typeof this.ragService.search === 'function') {
                // 備用方法名稱
                ragResults = await this.ragService.search(queryText, { limit: 5 });
            } else if (typeof this.ragService.searchByText === 'function') {
                // 另一個可能的方法名稱
                ragResults = await this.ragService.searchByText(queryText);
            } else {
                Logger.warn('⚠️ RAG Service 沒有可用的搜尋方法');
                return [];
            }

            // ✅ 確保返回的是陣列
            const results = Array.isArray(ragResults) ? ragResults : [];

            Logger.success(`✅ RAG 檢索完成: ${results.length} 個相關文檔`);
            return results;

        } catch (error) {
            Logger.error('❌ RAG 檢索失敗', error.message);
            // ✅ 返回空陣列，不中斷流程
            return [];
        }
    }


    // ═══════════════════════════════════════════
    // 輔助方法:生成合規報告(PDF/Excel)
    // ═══════════════════════════════════════════
    async generateComplianceReports(sessionId, data) {
        try {
            Logger.info('📄 生成 PDF 和 Excel 報告');
            const reportService = this.complianceReportService;

            if (!reportService) {
                Logger.warn('⚠️ ComplianceReportService 不可用');
                return null;
            }

            const fs = require('fs').promises;
            const reportsDir = './reports';

            // 確保目錄存在
            try {
                await fs.mkdir(reportsDir, { recursive: true });
            } catch (err) {
                if (err.code !== 'EEXIST') throw err;
            }

            // 用最終 API/前端需要的結構
            const pentestResults = {
                sessionId,
                executiveSummary: data.executiveSummary,
                attackResults: data.attackResults,
                grokReports: data.grokReports, // 這層就同前端：含 pentestReport/attackRecommendations
                geminiRecommendations: data.geminiRecommendations,
                ragContext: data.ragContext,
                downloads: data.downloads,
                metadata: {
                    ...data.metadata,
                    generatedAt: new Date().toISOString(),
                    uploadedFile: `Pentest Session: ${sessionId}`
                }
            };

            const options = {
                complianceFrameworks: ['ISO_27001', 'OWASP', 'NIST'],
                includeAuditTrail: true
            };

            // 生成 PDF 報告
            Logger.info('📄 生成 PDF 報告...');
            let pdfPath = null;
            try {
                const pdfBuffer = await reportService.generateComplianceReport(
                    pentestResults,
                    { ...options, format: 'pdf' }
                );
                if (pdfBuffer && pdfBuffer.length > 0) {
                    const pdfFilePath = `${reportsDir}/${sessionId}.pdf`;
                    await fs.writeFile(pdfFilePath, pdfBuffer);
                    pdfPath = `/reports/${sessionId}.pdf`;
                    Logger.success(`✅ PDF 報告生成成功: ${pdfFilePath}`);
                } else {
                    Logger.warn('⚠️ PDF Buffer 為空');
                }
            } catch (pdfError) {
                Logger.error('❌ PDF 報告生成失敗', pdfError.message);
                Logger.error(pdfError.stack);
            }

            // 生成 Excel 報告
            Logger.info('📊 生成 Excel 報告...');
            let excelPath = null;
            try {
                const excelBuffer = await reportService.generateComplianceReport(
                    pentestResults,
                    { ...options, format: 'excel' }
                );
                if (excelBuffer && excelBuffer.length > 0) {
                    const excelFilePath = `${reportsDir}/${sessionId}.xlsx`;
                    await fs.writeFile(excelFilePath, excelBuffer);
                    excelPath = `/reports/${sessionId}.xlsx`;
                    Logger.success(`✅ Excel 報告生成成功: ${excelFilePath}`);
                } else {
                    Logger.warn('⚠️ Excel Buffer 為空');
                }
            } catch (excelError) {
                Logger.error('❌ Excel 報告生成失敗', excelError.message);
                Logger.error(excelError.stack);
            }

            if (!pdfPath && !excelPath) {
                Logger.warn('⚠️ 無法生成任何報告檔案');
                return null;
            }

            return { pdfPath, excelPath };

        } catch (error) {
            Logger.error('❌ 報告生成過程失敗', error.message);
            Logger.error(error.stack);
            return null;
        }
    }



    // ═══════════════════════════════════════════
    // 輔助方法：計算安全指標
    // ═══════════════════════════════════════════
    calculateSecurityMetrics(results) {
        const successful = results.filter(r => r.success);
        const failed = results.filter(r => !r.success);

        // APCER (攻擊呈現分類錯誤率)
        const apcer = successful.length > 0
            ? successful.reduce((sum, r) => sum + (1 - r.confidence), 0) / successful.length
            : 0;

        // BPCER (正常呈現分類錯誤率)
        const bpcer = failed.length > 0
            ? failed.reduce((sum, r) => sum + r.confidence, 0) / failed.length
            : 0;

        return {
            apcer: (apcer * 100).toFixed(2) + '%',
            bpcer: (bpcer * 100).toFixed(2) + '%',
            acer: (((apcer + bpcer) / 2) * 100).toFixed(2) + '%',
            eer: (((apcer + bpcer) / 2) * 100).toFixed(2) + '%',
            rocAuc: ((1 - (apcer + bpcer) / 2) * 100).toFixed(2) + '%'
        };
    }

    // ═══════════════════════════════════════════
    // 輔助方法：生成 Session ID
    // ═══════════════════════════════════════════
    generateSessionId() {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 8).toUpperCase();
        return `PENTEST_${timestamp}_${random}`;
    }

    // ═══════════════════════════════════════════
    // 輔助方法：格式化執行時間
    // ═══════════════════════════════════════════
    formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);

        if (minutes > 0) {
            return `${minutes} 分 ${seconds % 60} 秒`;
        }
        return `${seconds} 秒`;
    }

    // 在 PentestOrchestrator.js 中修正

    // ═══════════════════════════════════════════
    // 階段 6: Gemini 生成企業改善建議（帶回退）
    // ═══════════════════════════════════════════
    async executeStage6_GeminiRemediation(grokPentestReport, ragContext) {
        Logger.info('🛡️ 階段 6: Gemini 生成企業改善建議');

        try {
            // ✅ 檢查方法是否存在
            if (typeof this.geminiService.generateEnterpriseRemediation === 'function') {
                return await this.geminiService.generateEnterpriseRemediation(
                    grokPentestReport.response,
                    ragContext
                );
            }

            // ✅ 回退：使用通用方法
            Logger.warn('⚠️ generateEnterpriseRemediation 不存在，使用回退方案');

            if (typeof this.geminiService.generateResponseWithContext === 'function') {
                const prompt = `請基於以下 Grok 滲透測試報告，為企業提供改善建議：\n\n${grokPentestReport.response}`;
                return await this.geminiService.generateResponseWithContext(prompt, ragContext);
            }

            // ✅ 最後回退：返回模擬回應
            return {
                success: true,
                remediationPlan: '⚠️ Gemini Service 方法不完整，請更新 GeminiService.js',
                model: 'fallback',
                confidence: 0.5,
                ragSourcesUsed: 0,
                timestamp: new Date().toISOString()
            };

        } catch (error) {
            Logger.error('❌ Gemini 企業建議生成失敗', error.message);
            return {
                success: false,
                remediationPlan: `錯誤：${error.message}`,
                model: 'error',
                confidence: 0,
                ragSourcesUsed: 0,
                timestamp: new Date().toISOString()
            };
        }
    }

    // ═══════════════════════════════════════════
    // 階段 7: Gemini 生成防禦策略（帶回退）
    // ═══════════════════════════════════════════
    async executeStage7_GeminiDefense(grokAttackRecommendations, ragContext) {
        Logger.info('🛡️ 階段 7: Gemini 生成防禦策略');

        try {
            // ✅ 檢查方法是否存在
            if (typeof this.geminiService.generateDefenseStrategy === 'function') {
                return await this.geminiService.generateDefenseStrategy(
                    grokAttackRecommendations.response,
                    ragContext
                );
            }

            // ✅ 回退方案
            Logger.warn('⚠️ generateDefenseStrategy 不存在，使用回退方案');

            return {
                success: true,
                defenseStrategy: '⚠️ 請更新 GeminiService.js 以啟用完整功能',
                model: 'fallback',
                confidence: 0.5,
                ragSourcesUsed: 0,
                timestamp: new Date().toISOString()
            };

        } catch (error) {
            Logger.error('❌ Gemini 防禦策略生成失敗', error.message);
            return {
                success: false,
                defenseStrategy: `錯誤：${error.message}`,
                model: 'error',
                confidence: 0,
                ragSourcesUsed: 0,
                timestamp: new Date().toISOString()
            };
        }
    }

}

module.exports = PentestOrchestrator;
