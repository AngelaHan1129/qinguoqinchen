// src/services/PentestOrchestrator.js - å®Œæ•´æ•´åˆç‰ˆæœ¬
const Logger = require('../utils/logger');
const { generatePentestReport } = require('./reportService');

class PentestOrchestrator {
    constructor(services) {
        const {
            attackService,
            grokService,
            geminiService,
            ragService,
            complianceReportService,
            zapService
        } = services;

        this.attackService = attackService;
        this.grokService = grokService;
        this.geminiService = geminiService;
        this.ragService = ragService;
        this.complianceReportService = complianceReportService;
        this.zapService = zapService;

        Logger.info('âœ… PentestOrchestrator åˆå§‹åŒ–æˆåŠŸ');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // æ ¸å¿ƒæ–¹æ³•ï¼šåŸ·è¡Œå®Œæ•´æ»²é€æ¸¬è©¦æµç¨‹
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async executeFullPenetrationTest(params) {
        const {
            vectorIds = ['A1', 'A2', 'A3', 'A4', 'A5'],
            intensity = 'medium',
            targetUrl = 'http://localhost:3000',
            generateReports = true
        } = params;

        const sessionId = this.generateSessionId();
        const startTime = Date.now();
        const { reportMarkdown, results } = await generatePentestReport({
            vectorIds: params.vectorIds,
            intensity: params.intensity,
            targetUrl: params.targetUrl,
            modelInfo: params.modelInfo, // æ”¯æ´å®¢è£½
            clientName: params.clientName,
            testStartTime: params.testStartTime,
            testEndTime: Date.now(),
            testUser: params.testUser
        });
        Logger.info('ğŸ¯ é–‹å§‹åŸ·è¡Œå®Œæ•´æ»²é€æ¸¬è©¦', {
            sessionId,
            vectorIds,
            intensity,
            targetUrl
        });

        try {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 1: åŸ·è¡Œæ”»æ“Šæ¸¬è©¦
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Logger.info('âš”ï¸ éšæ®µ 1: åŸ·è¡Œæ”»æ“Šæ¸¬è©¦');
            const attackResults = await this.executeAttacks(vectorIds, intensity, targetUrl);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 2: ZAP æƒæï¼ˆå¯é¸ï¼‰
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let zapResults = null;
            if (this.zapService) {
                Logger.info('ğŸ” éšæ®µ 2: åŸ·è¡Œ ZAP æƒæï¼ˆå¯é¸ï¼‰');
                zapResults = await this.executeZAPScan(targetUrl);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 3: Grok ç”Ÿæˆæ»²é€æ¸¬è©¦å ±å‘Š
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Logger.info('ğŸ“Š éšæ®µ 3: Grok ç”Ÿæˆæ»²é€æ¸¬è©¦å ±å‘Š');
            // å‘¼å«è™•ï¼ˆorchestrator æˆ– controllerï¼‰
            const grokPentestReport = await this.grokService.generatePentestReport(
                attackResults,            // ç¬¬ä¸€å€‹åƒæ•¸
                zapResults,               // ç¬¬äºŒå€‹åƒæ•¸
                {                        // ç¬¬ä¸‰å€‹åƒæ•¸ï¼Œé€™è£¡è¦å‚³ systemContext æˆ– targetInfo
                    url: targetUrl,
                    type: 'eKYC System',
                    version: '1.0',
                    industry: 'é‡‘è'
                }
            );


            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 4: Grok ç”Ÿæˆæ”»æ“Šè€…ä¸‹æ¬¡å»ºè­°
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Logger.info('âš”ï¸ éšæ®µ 4: Grok ç”Ÿæˆæ”»æ“Šè€…ä¸‹æ¬¡å»ºè­°');
            const grokAttackRecommendations = await this.grokService.generateNextAttackRecommendations(
                attackResults,
                zapResults,
                [] // å¯å‚³å…¥æ­·å²æ”»æ“Šè¨˜éŒ„
            );

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 5: RAG æª¢ç´¢ç›¸é—œå®‰å…¨çŸ¥è­˜
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Logger.info('ğŸ“š éšæ®µ 5: RAG æª¢ç´¢å®‰å…¨çŸ¥è­˜åº«');
            const ragContext = await this.retrieveRelevantKnowledge(
                attackResults,
                grokPentestReport.response
            );

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 6: Gemini ç”Ÿæˆä¼æ¥­æ”¹å–„å»ºè­°ï¼ˆåŸºæ–¼ Grok å ±å‘Š + RAGï¼‰
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Logger.info('ğŸ›¡ï¸ éšæ®µ 6: Gemini ç”Ÿæˆä¼æ¥­æ”¹å–„å»ºè­°');
            const geminiEnterpriseRemediation = await this.executeStage6_GeminiRemediation(
                grokPentestReport,
                ragContext
            );

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 7: Gemini ç”Ÿæˆé˜²ç¦¦ç­–ç•¥ï¼ˆåŸºæ–¼ Grok æ”»æ“Šå»ºè­° + RAGï¼‰
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            Logger.info('ğŸ›¡ï¸ éšæ®µ 7: Gemini ç”Ÿæˆé˜²ç¦¦ç­–ç•¥');
            const geminiDefenseStrategy = await this.executeStage7_GeminiDefense(
                grokAttackRecommendations,
                ragContext
            );

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 8: ç”Ÿæˆ PDF/Excel å ±å‘Šï¼ˆå¯é¸ï¼‰
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let reportFiles = null;
            if (generateReports && this.complianceReportService) {
                Logger.info('ğŸ“„ éšæ®µ 8: ç”Ÿæˆ PDF å’Œ Excel å ±å‘Š');
                reportFiles = await this.generateComplianceReports(
                    sessionId,
                    {
                        attackResults,
                        grokPentestReport,
                        grokAttackRecommendations,
                        geminiEnterpriseRemediation,
                        geminiDefenseStrategy,
                        ragContext
                    }
                );
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // éšæ®µ 9: çµ„è£æœ€çµ‚çµæœ
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const executionTime = Date.now() - startTime;
            const summary = attackResults?.summary || {};
            const results = attackResults?.results || [];

            const finalResult = {
                success: true,
                sessionId,

                // åŸ·è¡Œæ‘˜è¦
                executiveSummary: {
                    totalVectors: vectorIds.length,
                    successfulAttacks: summary.successfulAttacks || 0,
                    failedAttacks: (summary.totalAttacks || vectorIds.length) - (summary.successfulAttacks || 0),
                    overallSuccessRate: summary.overallSuccessRate || '0%',
                    riskLevel: summary.riskLevel || 'UNKNOWN',
                    testDuration: this.formatDuration(executionTime),
                    timestamp: new Date().toISOString()
                },

                // æ”»æ“Šçµæœï¼ˆåŸå§‹æ•¸æ“šï¼‰
                attackResults: {
                    vectors: results,
                    summary: summary,
                    metrics: this.calculateSecurityMetrics(results)
                },

                // ZAP æƒæçµæœï¼ˆå¯é¸ï¼‰
                zapResults: zapResults || null,

                // ğŸ”´ Grok ç”Ÿæˆçš„å ±å‘Šï¼ˆçµ¦æŠ€è¡“åœ˜éšŠçœ‹ï¼‰
                grokReports: {
                    pentestReport: {
                        content: grokPentestReport?.response || '',
                        model: grokPentestReport?.model || 'unknown',
                        timestamp: grokPentestReport?.timestamp || new Date().toISOString()
                    },
                    attackRecommendations: {
                        content: grokAttackRecommendations?.response || '',
                        model: grokAttackRecommendations?.model || 'unknown',
                        timestamp: grokAttackRecommendations?.timestamp || new Date().toISOString()
                    }
                },

                // ğŸŸ¢ Gemini ç”Ÿæˆçš„å»ºè­°ï¼ˆçµ¦ä¼æ¥­/ç®¡ç†å±¤çœ‹ï¼‰
                geminiRecommendations: {
                    enterpriseRemediation: {
                        content: geminiEnterpriseRemediation?.remediationPlan || '',
                        model: geminiEnterpriseRemediation?.model || 'fallback',
                        confidence: geminiEnterpriseRemediation?.confidence || 0.5,
                        ragSourcesUsed: geminiEnterpriseRemediation?.ragSourcesUsed || 0,
                        timestamp: geminiEnterpriseRemediation?.timestamp || new Date().toISOString()
                    },
                    defenseStrategy: {
                        content: geminiDefenseStrategy?.defenseStrategy || '',
                        model: geminiDefenseStrategy?.model || 'fallback',
                        confidence: geminiDefenseStrategy?.confidence || 0.5,
                        ragSourcesUsed: geminiDefenseStrategy?.ragSourcesUsed || 0,
                        timestamp: geminiDefenseStrategy?.timestamp || new Date().toISOString()
                    }
                },

                // RAG çŸ¥è­˜åº«ä¾†æº
                ragContext: {
                    totalSources: Array.isArray(ragContext) ? ragContext.length : 0,
                    sources: Array.isArray(ragContext) ? ragContext.map(doc => ({
                        title: doc?.title || 'Unknown',
                        category: doc?.category || 'general',
                        similarity: doc?.similarity || 0
                    })) : []
                },

                // ä¸‹è¼‰é€£çµ
                downloads: {
                    pdfReport: reportFiles?.pdfPath || null,
                    excelReport: reportFiles?.excelPath || null
                },

                // å…ƒæ•¸æ“š
                metadata: {
                    executionTime: `${executionTime}ms`,
                    generatedAt: new Date().toISOString(),
                    version: '2.0.0',
                    system: 'ä¾µåœ‹ä¾µåŸ AI æ»²é€æ¸¬è©¦ç³»çµ±',
                    aiModels: {
                        attackAnalysis: 'Grok AI',
                        enterpriseRemediation: 'Gemini 2.5 Flash',
                        knowledgeBase: 'RAG (pgvector)'
                    }
                }
            };

            Logger.success('âœ… å®Œæ•´æ»²é€æ¸¬è©¦åŸ·è¡ŒæˆåŠŸ', {
                sessionId,
                duration: executionTime,
                successRate: summary.overallSuccessRate || '0%'
            });

            return finalResult;

        } catch (error) {
            Logger.error('âŒ æ»²é€æ¸¬è©¦åŸ·è¡Œå¤±æ•—', error.message);

            return {
                success: false,
                sessionId,
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // è¼”åŠ©æ–¹æ³•ï¼šåŸ·è¡Œæ”»æ“Šæ¸¬è©¦
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async executeAttacks(vectorIds, intensity, targetUrl) {
        Logger.info('âš”ï¸ åŸ·è¡Œæ”»æ“Šå‘é‡æ¸¬è©¦', { vectorIds, intensity });

        const attackResult = this.attackService.executeAttack({
            vectorIds,
            intensity,
            targetImage: null,
            targetUrl,
            options: {}
        });

        return attackResult;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // è¼”åŠ©æ–¹æ³•ï¼šåŸ·è¡Œ ZAP æƒæ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async executeZAPScan(targetUrl) {
        if (!this.zapService) {
            Logger.warn('âš ï¸ ZAP Service ä¸å¯ç”¨ï¼Œè·³éæƒæ');
            return null;
        }

        try {
            Logger.info('ğŸ” åŸ·è¡Œ OWASP ZAP æƒæ');
            // å‡è¨­ zapService æœ‰ scan æ–¹æ³•
            const zapResult = await this.zapService.scan(targetUrl);
            return zapResult;
        } catch (error) {
            Logger.warn('âš ï¸ ZAP æƒæå¤±æ•—', error.message);
            return null;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // è¼”åŠ©æ–¹æ³•ï¼šRAG æª¢ç´¢ç›¸é—œçŸ¥è­˜
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async retrieveRelevantKnowledge(attackResults, grokReport) {
        if (!this.ragService) {
            Logger.warn('âš ï¸ RAG Service ä¸å¯ç”¨');
            return [];
        }

        try {
            Logger.info('ğŸ“š æª¢ç´¢ RAG çŸ¥è­˜åº«');

            // âœ… ä¿®æ­£ï¼šå®‰å…¨åœ°æå–æ”»æ“Šå‘é‡åç¨±
            const vectorNames = (attackResults?.results || [])
                .map(r => r.vectorName || 'Unknown')
                .filter(name => name !== 'Unknown')
                .join(', ') || 'æœªçŸ¥æ”»æ“Šå‘é‡';

            const queryText = `
eKYC å®‰å…¨æ¼æ´ä¿®å¾©å»ºè­°
æ”»æ“Šå‘é‡: ${vectorNames}
é¢¨éšªç­‰ç´š: ${attackResults?.summary?.riskLevel || 'UNKNOWN'}
æˆåŠŸç‡: ${attackResults?.summary?.overallSuccessRate || '0%'}
`;

            // âœ… æª¢æŸ¥ RAG Service æ˜¯å¦æœ‰æ­£ç¢ºçš„æ–¹æ³•
            let ragResults = [];

            if (typeof this.ragService.searchRelevantDocuments === 'function') {
                ragResults = await this.ragService.searchRelevantDocuments(
                    queryText,
                    { topK: 5, category: 'security', documentType: 'remediation' }
                );
            } else if (typeof this.ragService.search === 'function') {
                // å‚™ç”¨æ–¹æ³•åç¨±
                ragResults = await this.ragService.search(queryText, { limit: 5 });
            } else if (typeof this.ragService.searchByText === 'function') {
                // å¦ä¸€å€‹å¯èƒ½çš„æ–¹æ³•åç¨±
                ragResults = await this.ragService.searchByText(queryText);
            } else {
                Logger.warn('âš ï¸ RAG Service æ²’æœ‰å¯ç”¨çš„æœå°‹æ–¹æ³•');
                return [];
            }

            // âœ… ç¢ºä¿è¿”å›çš„æ˜¯é™£åˆ—
            const results = Array.isArray(ragResults) ? ragResults : [];

            Logger.success(`âœ… RAG æª¢ç´¢å®Œæˆ: ${results.length} å€‹ç›¸é—œæ–‡æª”`);
            return results;

        } catch (error) {
            Logger.error('âŒ RAG æª¢ç´¢å¤±æ•—', error.message);
            // âœ… è¿”å›ç©ºé™£åˆ—ï¼Œä¸ä¸­æ–·æµç¨‹
            return [];
        }
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // è¼”åŠ©æ–¹æ³•:ç”Ÿæˆåˆè¦å ±å‘Š(PDF/Excel)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async generateComplianceReports(sessionId, data) {
        try {
            Logger.info('ğŸ“„ ç”Ÿæˆ PDF å’Œ Excel å ±å‘Š');
            const reportService = this.complianceReportService;

            if (!reportService) {
                Logger.warn('âš ï¸ ComplianceReportService ä¸å¯ç”¨');
                return null;
            }

            const fs = require('fs').promises;
            const reportsDir = './reports';

            // ç¢ºä¿ç›®éŒ„å­˜åœ¨
            try {
                await fs.mkdir(reportsDir, { recursive: true });
            } catch (err) {
                if (err.code !== 'EEXIST') throw err;
            }

            // ç”¨æœ€çµ‚ API/å‰ç«¯éœ€è¦çš„çµæ§‹
            const pentestResults = {
                sessionId,
                executiveSummary: data.executiveSummary,
                attackResults: data.attackResults,
                grokReports: data.grokReports, // é€™å±¤å°±åŒå‰ç«¯ï¼šå« pentestReport/attackRecommendations
                geminiRecommendations: data.geminiRecommendations,
                ragContext: data.ragContext,
                downloads: data.downloads,
                metadata: {
                    ...data.metadata,
                    generatedAt: new Date().toISOString(),
                    uploadedFile: `Pentest Session: ${sessionId}`
                }
            };

            const options = {
                complianceFrameworks: ['ISO_27001', 'OWASP', 'NIST'],
                includeAuditTrail: true
            };

            // ç”Ÿæˆ PDF å ±å‘Š
            Logger.info('ğŸ“„ ç”Ÿæˆ PDF å ±å‘Š...');
            let pdfPath = null;
            try {
                const pdfBuffer = await reportService.generateComplianceReport(
                    pentestResults,
                    { ...options, format: 'pdf' }
                );
                if (pdfBuffer && pdfBuffer.length > 0) {
                    const pdfFilePath = `${reportsDir}/${sessionId}.pdf`;
                    await fs.writeFile(pdfFilePath, pdfBuffer);
                    pdfPath = `/reports/${sessionId}.pdf`;
                    Logger.success(`âœ… PDF å ±å‘Šç”ŸæˆæˆåŠŸ: ${pdfFilePath}`);
                } else {
                    Logger.warn('âš ï¸ PDF Buffer ç‚ºç©º');
                }
            } catch (pdfError) {
                Logger.error('âŒ PDF å ±å‘Šç”Ÿæˆå¤±æ•—', pdfError.message);
                Logger.error(pdfError.stack);
            }

            // ç”Ÿæˆ Excel å ±å‘Š
            Logger.info('ğŸ“Š ç”Ÿæˆ Excel å ±å‘Š...');
            let excelPath = null;
            try {
                const excelBuffer = await reportService.generateComplianceReport(
                    pentestResults,
                    { ...options, format: 'excel' }
                );
                if (excelBuffer && excelBuffer.length > 0) {
                    const excelFilePath = `${reportsDir}/${sessionId}.xlsx`;
                    await fs.writeFile(excelFilePath, excelBuffer);
                    excelPath = `/reports/${sessionId}.xlsx`;
                    Logger.success(`âœ… Excel å ±å‘Šç”ŸæˆæˆåŠŸ: ${excelFilePath}`);
                } else {
                    Logger.warn('âš ï¸ Excel Buffer ç‚ºç©º');
                }
            } catch (excelError) {
                Logger.error('âŒ Excel å ±å‘Šç”Ÿæˆå¤±æ•—', excelError.message);
                Logger.error(excelError.stack);
            }

            if (!pdfPath && !excelPath) {
                Logger.warn('âš ï¸ ç„¡æ³•ç”Ÿæˆä»»ä½•å ±å‘Šæª”æ¡ˆ');
                return null;
            }

            return { pdfPath, excelPath };

        } catch (error) {
            Logger.error('âŒ å ±å‘Šç”Ÿæˆéç¨‹å¤±æ•—', error.message);
            Logger.error(error.stack);
            return null;
        }
    }



    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // è¼”åŠ©æ–¹æ³•ï¼šè¨ˆç®—å®‰å…¨æŒ‡æ¨™
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    calculateSecurityMetrics(results) {
        const successful = results.filter(r => r.success);
        const failed = results.filter(r => !r.success);

        // APCER (æ”»æ“Šå‘ˆç¾åˆ†é¡éŒ¯èª¤ç‡)
        const apcer = successful.length > 0
            ? successful.reduce((sum, r) => sum + (1 - r.confidence), 0) / successful.length
            : 0;

        // BPCER (æ­£å¸¸å‘ˆç¾åˆ†é¡éŒ¯èª¤ç‡)
        const bpcer = failed.length > 0
            ? failed.reduce((sum, r) => sum + r.confidence, 0) / failed.length
            : 0;

        return {
            apcer: (apcer * 100).toFixed(2) + '%',
            bpcer: (bpcer * 100).toFixed(2) + '%',
            acer: (((apcer + bpcer) / 2) * 100).toFixed(2) + '%',
            eer: (((apcer + bpcer) / 2) * 100).toFixed(2) + '%',
            rocAuc: ((1 - (apcer + bpcer) / 2) * 100).toFixed(2) + '%'
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // è¼”åŠ©æ–¹æ³•ï¼šç”Ÿæˆ Session ID
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    generateSessionId() {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 8).toUpperCase();
        return `PENTEST_${timestamp}_${random}`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // è¼”åŠ©æ–¹æ³•ï¼šæ ¼å¼åŒ–åŸ·è¡Œæ™‚é–“
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);

        if (minutes > 0) {
            return `${minutes} åˆ† ${seconds % 60} ç§’`;
        }
        return `${seconds} ç§’`;
    }

    // åœ¨ PentestOrchestrator.js ä¸­ä¿®æ­£

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // éšæ®µ 6: Gemini ç”Ÿæˆä¼æ¥­æ”¹å–„å»ºè­°ï¼ˆå¸¶å›é€€ï¼‰
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async executeStage6_GeminiRemediation(grokPentestReport, ragContext) {
        Logger.info('ğŸ›¡ï¸ éšæ®µ 6: Gemini ç”Ÿæˆä¼æ¥­æ”¹å–„å»ºè­°');

        try {
            // âœ… æª¢æŸ¥æ–¹æ³•æ˜¯å¦å­˜åœ¨
            if (typeof this.geminiService.generateEnterpriseRemediation === 'function') {
                return await this.geminiService.generateEnterpriseRemediation(
                    grokPentestReport.response,
                    ragContext
                );
            }

            // âœ… å›é€€ï¼šä½¿ç”¨é€šç”¨æ–¹æ³•
            Logger.warn('âš ï¸ generateEnterpriseRemediation ä¸å­˜åœ¨ï¼Œä½¿ç”¨å›é€€æ–¹æ¡ˆ');

            if (typeof this.geminiService.generateResponseWithContext === 'function') {
                const prompt = `è«‹åŸºæ–¼ä»¥ä¸‹ Grok æ»²é€æ¸¬è©¦å ±å‘Šï¼Œç‚ºä¼æ¥­æä¾›æ”¹å–„å»ºè­°ï¼š\n\n${grokPentestReport.response}`;
                return await this.geminiService.generateResponseWithContext(prompt, ragContext);
            }

            // âœ… æœ€å¾Œå›é€€ï¼šè¿”å›æ¨¡æ“¬å›æ‡‰
            return {
                success: true,
                remediationPlan: 'âš ï¸ Gemini Service æ–¹æ³•ä¸å®Œæ•´ï¼Œè«‹æ›´æ–° GeminiService.js',
                model: 'fallback',
                confidence: 0.5,
                ragSourcesUsed: 0,
                timestamp: new Date().toISOString()
            };

        } catch (error) {
            Logger.error('âŒ Gemini ä¼æ¥­å»ºè­°ç”Ÿæˆå¤±æ•—', error.message);
            return {
                success: false,
                remediationPlan: `éŒ¯èª¤ï¼š${error.message}`,
                model: 'error',
                confidence: 0,
                ragSourcesUsed: 0,
                timestamp: new Date().toISOString()
            };
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // éšæ®µ 7: Gemini ç”Ÿæˆé˜²ç¦¦ç­–ç•¥ï¼ˆå¸¶å›é€€ï¼‰
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async executeStage7_GeminiDefense(grokAttackRecommendations, ragContext) {
        Logger.info('ğŸ›¡ï¸ éšæ®µ 7: Gemini ç”Ÿæˆé˜²ç¦¦ç­–ç•¥');

        try {
            // âœ… æª¢æŸ¥æ–¹æ³•æ˜¯å¦å­˜åœ¨
            if (typeof this.geminiService.generateDefenseStrategy === 'function') {
                return await this.geminiService.generateDefenseStrategy(
                    grokAttackRecommendations.response,
                    ragContext
                );
            }

            // âœ… å›é€€æ–¹æ¡ˆ
            Logger.warn('âš ï¸ generateDefenseStrategy ä¸å­˜åœ¨ï¼Œä½¿ç”¨å›é€€æ–¹æ¡ˆ');

            return {
                success: true,
                defenseStrategy: 'âš ï¸ è«‹æ›´æ–° GeminiService.js ä»¥å•Ÿç”¨å®Œæ•´åŠŸèƒ½',
                model: 'fallback',
                confidence: 0.5,
                ragSourcesUsed: 0,
                timestamp: new Date().toISOString()
            };

        } catch (error) {
            Logger.error('âŒ Gemini é˜²ç¦¦ç­–ç•¥ç”Ÿæˆå¤±æ•—', error.message);
            return {
                success: false,
                defenseStrategy: `éŒ¯èª¤ï¼š${error.message}`,
                model: 'error',
                confidence: 0,
                ragSourcesUsed: 0,
                timestamp: new Date().toISOString()
            };
        }
    }

}

module.exports = PentestOrchestrator;
